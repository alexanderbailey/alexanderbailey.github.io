# Calculates ascendingly generated Cayley tables

n:=7;    # Semigroup of order n
k:=5;    # generated ascendingly by first k elements
e:=100;  # Number of jobs
c:=1;    # Which job to run now

# Finds the elements generated by M in their shortlex order

ShortlexClosureOfSet:=function(S,M,n)
  local OldElts,NewElts,TempList,i,j,t;
  OldElts:=ShallowCopy(M);
  NewElts:=ShallowCopy(M);
  while Size(NewElts)>0 and Size(OldElts)<n do;
    TempList:=[];
    for i in OldElts do;
      for j in NewElts do;
        Add(TempList,S[i][j]);
      od;
    od;
    for i in NewElts do;
      for j in OldElts do;
        Add(TempList,S[i][j]);
      od;
    od;
    for t in NewElts do;
      if not t in OldElts then Add(OldElts,t); fi;
    od;
    NewElts:=[];
    for t in TempList do;
      if not t in OldElts and not t in NewElts then Add(NewElts,t); fi;
    od;
  od;
  return OldElts;
end;

# Inverts a permuation

InversePerm:=function(C,n)
  local Perm,x;
  Perm:=[1..n];
  for x in [1..n] do;
    Perm[C[x]]:=x;
  od;
  return Perm;
end;

# Finds image of a Cayley table by some permutation (including dual)

PermImageWithDual:=function(p,T,n)
  local TempTable,TempTableDual,x,y;
  TempTable:=NullMat(n,n);
  TempTableDual:=NullMat(n,n);
  for x in [1..n] do;
    for y in [1..n] do;
      TempTable[p[x]][p[y]]:=p[T[x][y]];
      TempTableDual[p[x]][p[y]]:=p[T[y][x]];
    od;
  od;
  return [TempTable,TempTableDual];
end;

# Finds image of a Cayley table by some permutation (without dual)

PermImage:=function(p,T,n)
  local TempTable,x,y;
  TempTable:=NullMat(n,n);
  for x in [1..n] do;
    for y in [1..n] do;
      TempTable[p[x]][p[y]]:=p[T[x][y]];
    od;
  od;
  return TempTable;
end;

# Create list of all possible generating sets and permutations that send them to [1..k]

PossibleGenSets:=Combinations([1..n],k);
P:=[];
for p in SymmetricGroup(k) do;
  Add(P,Concatenation(ListPerm(p,k),[k+1..n]));
od;

# Only read the semigroups of order n that are generated by at most k generators

LoadPackage("smallsemi");
Q:=NullMat(k,1);
Q[1]:=EnumeratorOfSmallSemigroups(n,IsMonogenicSemigroup,true);
if k>1 then
  Q[2]:=EnumeratorOfSmallSemigroups(n,Is2GeneratedSemigroup,true);
  if k>2 then
    Q[3]:=EnumeratorOfSmallSemigroups(n,Is3GeneratedSemigroup,true);
    if k>3 then
      Q[4]:=EnumeratorOfSmallSemigroups(n,Is4GeneratedSemigroup,true);
      if k>4 then
        Q[5]:=EnumeratorOfSmallSemigroups(n,Is5GeneratedSemigroup,true);
        if k>5 then
          Q[6]:=EnumeratorOfSmallSemigroups(n,Is6GeneratedSemigroup,true);
          if k>6 then
            Q[7]:=EnumeratorOfSmallSemigroups(n,Is7GeneratedSemigroup,true);
fi;fi;fi;fi;fi;fi;
Y:=[];
for j in [1..k] do;
  for q in Q[j] do;
    Add(Y,IdSmallSemigroup(q)[2]);
  od;
od;

W:=[];

Print("Calculating semigroups in range [",Int((e-1)*Size(Y)/c)+1,"..",Int(e*Size(Y)/c),"]\n");
for i in [Int((e-1)*Size(Y)/c)+1..Int(e*Size(Y)/c)] do;
  # For each (anti-)isomorphic representative of at most k generated semigroups of order n...
  T:=RecoverMultiplicationTableNC(n,Y[i]);
  # For each possible generating set
  for G in PossibleGenSets do;
    # Find shortlex closure of generating set
    C:=ShortlexClosureOfSet(T,G,n);
    # If it is a generating set then...
    if Size(C)=n then
     # Permute Cayley table so generating set is sent to [1..k]
      FirstPerm:=InversePerm(C,n);
      S:=PermImage(FirstPerm,T,n);
      Add(W,S);
      # For each permuation of generating set...
      for p in P do;
        for U in PermImageWithDual(p,S,n) do;
          # Permute the Cayley table and rerrange non-generators in to shortlex order so that it is ascendingly generated
          Add(W,PermImage(InversePerm(ShortlexClosureOfSet(U,[1..k],n),n),U,n));
        od;
      od;
    fi;
  od;
od;
# Print number of distinct Cayley tables
Print(Size(Set(W)));


